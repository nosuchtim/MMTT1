#include <FFGL.h>
#include <FFGLLib.h>
#include <pthread.h>
#include <iostream>
#include <fstream>

#include  <io.h>
#include  <stdlib.h>

#include <time.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#include <errno.h>

#include <sys/types.h>
#include <fcntl.h>
#include <errno.h>
#include <vector>
#include <string>
#include <iostream>

#include <cstdlib> // for srand, rand

#include "NosuchUtil.h"
#include "PaletteFF.h"
#include "Event.h"
#include "Behaviour.h"
#include "GraphicBehaviour.h"
#include "MusicBehaviour.h"
#include "Palette.h"
#include "Param.h"
#include "Cursor.h"
#include "Sprite.h"
#include "Region.h"
#include "Sound.h"
#include "Resolume.h"
#include "Scale.h"

Palette* Palette::_singleton = NULL;
const std::string Palette::configSuffix = ".plt";
const std::string Palette::configSeparator = "\\";
int Palette::lastsprite = 0;
int Palette::now = 0;

int Palette::CurrentMuseumGraphic = 0;
int Palette::NumMuseumGraphics = 0;
int Palette::CurrentMayGraphic = 0;
int Palette::NumMayGraphics = 0;
int Palette::CurrentBurnGraphic = 0;
int Palette::NumBurnGraphics = 0;

std::map<std::string,int> Palette::paramTypes;

bool Palette::initialized = false;

ParamList* Palette::globalParams = NULL;
ParamList* Palette::globalDefaults = NULL;
ParamList* Palette::globalRegionOverrideParams = NULL;
ParamList* Palette::globalRegionOverrideDefaults = NULL;

bool Palette::isShiftDown() {
	return ( isButtonDown("UL3"));
}

static int ChannelLastChange[16] = {
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0
};

int Palette::setRegionSound(std::string region, std::string nm) {
	Region* r = GetRegionNamed(region);
	NosuchAssert(r);
	return setRegionSound(r,nm);
}

int Palette::setRegionSound(int rid, std::string nm) {
	Region* r = getRegion(rid);
	NosuchAssert(r);
	return setRegionSound(r,nm);
}

int Palette::setRegionSound(Region* r, std::string nm) {
	Param* ps = r->params()->get("sound",true);
	NosuchAssert(ps);
	NosuchDebug(1,"setRegionSound region=%s existing==%s new=%s",
		r->name.c_str(),r->sound.c_str(),nm.c_str());
	ps->setStringValue(nm);
	r->UpdateSound();
	return r->channel();
}

void Palette::changeSoundSet(int selected) {
	int sb = soundBank();

	NosuchAssert(selected>=0 && selected<NUM_SOUNDSETS);
	NosuchAssert(sb>=0 && sb<=NUM_SOUNDSETS);

	if ( SoundBank[sb][selected][0] == "" ) {
		NosuchDebug(ERROR_OUTPUT,"No sounds in soundbank %d !?",sb);
		return;
	}

	setRegionSound(1,SoundBank[sb][selected][0]);
	setRegionSound(2,SoundBank[sb][selected][1]);
	setRegionSound(3,SoundBank[sb][selected][2]);
	setRegionSound(4,SoundBank[sb][selected][3]);
	NosuchDebug(1,"CHANGED SOUND SET to number %d",selected);
	CurrentSoundSet = selected;
}

Region*
Palette::NewSurfaceNamed(std::string nm, int sid_low, int sid_high) {
	Region* r = newRegionNamed(nm);
	NosuchAssert(r);
	r->SetTypeAndSid(Region::SURFACE,sid_low,sid_high);
	return r;
}

Region*
Palette::NewButtonNamed(std::string nm, int sid_low, int sid_high) {
	Region* r = newRegionNamed(nm);
	NosuchAssert(r);
	r->SetTypeAndSid(Region::BUTTON,sid_low,sid_high);
	return r;
}

Region*
Palette::GetRegionNamed(std::string nm) {
	for ( size_t i=0; i < _regions.size(); i++ ) {
		if ( _regions[i]->name == nm ) {
			return _regions[i];
		}
	}
	NosuchDebug("Hey!  Unable to find a Region named %s !?",nm.c_str());
	return NULL;
}

Region*
Palette::newRegionNamed(std::string nm) {

	Region* r;
	int rid = _regions.size();
	if ( rid == 0 ) {
		r = new Region(this,rid);
		NosuchDebug("CREATING Root Region rid=%d",rid);
		_regions.push_back(r);
		r->name = "root";
		rid = 1;
	}
	r = new Region(this,rid);
	NosuchDebug("CREATING Region rid=%d",rid);
	_regions.push_back(r);

	// NosuchDebug("NEW REGION NAMED nm=%s  rid=%d",nm.c_str(),rid);
	r->name = nm;
	return r;
}

Region*
Palette::RegionForSid(std::string sid) {
	int sidnum = atoi(sid.c_str());
	for ( size_t i=0; i < _regions.size(); i++ ) {
		int sid_low = _regions[i]->sid_low;
		int sid_high = _regions[i]->sid_high;
		if ( sidnum >= sid_low && sidnum <= sid_high ) {
			return _regions[i];
		}
	}
	return NULL;
}
void Palette::UpdateSound(int regionid) {
	NosuchDebug("UpdateSound regionid=%d",regionid);
	if ( regionid == REGIONID_FOR_OVERRIDE_PARAMS ) {
		for ( size_t i=0; i < _regions.size(); i++ ) {
			_regions[i]->UpdateSound();
		}
	} else {
		_regions[regionid]->UpdateSound();
	}
}

int Palette::findSoundChannel(std::string nm, int regionid) {
	Sound& sound = Sounds[nm];
	std::string synthname = sound.synth();

	if ( synthname == "UNINITIALIZED" ) {
		NosuchDebug("HEY!, didn't find sound named %s in findSoundChannel!?",nm.c_str());
		return -1;
	}
	int patch = sound.patchnum();
	int oldestregion = -1;
	int oldestregiontime = -1;

	// look through all the channels and see if any are free (and
	// not the current channel)
	int existingchan;
	if ( regionid >= (int)_regions.size() ) {
		// shouldn't really happen except at startup?
		existingchan = -1;
	} else {
		existingchan = _regions[regionid]->channel();
	}

	NosuchDebug(1,"==== Palette::findSoundChannel start region=%d existingchan=%d nm=%s",
		regionid,existingchan,nm.c_str());

	int foundfreechannel = -1;
	// int foundchan = -1;
	int oldest_time = INT_MAX;
	int oldest_chan = -1;
	for ( int ch=1; ch<=16; ch++ ) {

		if ( Synths[ch] != synthname )
			continue;

		// Channel isn't currently used on any region - see which channel is the oldest
		NosuchDebug(1,"findSoundChannel region=%d, found synth=%s on channel ch=%d lastchange=%d",
			regionid, synthname.c_str(),ch,ChannelLastChange[ch]);
		if ( oldest_chan < 0 || ChannelLastChange[ch] < oldest_time ) {
			NosuchDebug(1,"   SETTING oldest_chan to %d",ch);
			oldest_chan = ch;
			oldest_time = ChannelLastChange[ch];
		}
		// return ch;
	}
	if ( oldest_chan < 0 ) {
		NosuchDebug("HEY!! findSoundChannel region=%d - resorting to existing channel %d for sound %s",
			regionid, existingchan,nm.c_str());
		ChannelLastChange[existingchan] = Palette::now;
		return existingchan;
	}
	NosuchDebug(1,"findSoundChannel region=%d - oldest_chan is %d for sound %s, setting lastchange to %d",
		regionid, oldest_chan,nm.c_str(),Palette::now);
	ChannelLastChange[oldest_chan] = Palette::now;
	return oldest_chan;
}

std::string Palette::paramTypeToTypeString(int i) {
	if ( i == MUSIC_PARAM )
		return "music";
	if ( i == GRAPHIC_PARAM )
		return "graphic";
	if ( i == GLOBAL_PARAM )
		return "global";
	NosuchDebug("Unknown param type value: "+i);
	return "";
}

#if 0
int Palette::paramNameToType(std::string nm) {
	return paramTypes[nm];
}
#endif

int Palette::paramTypeStringToType(std::string type) {
	if (type == "music")
		return MUSIC_PARAM;
	if (type == "graphic")
		return GRAPHIC_PARAM;
	if (type == "global")
		return GLOBAL_PARAM;
	if (type == "all")
		return ALL_PARAM;
	NosuchDebug("Unknown param type string: %s",type.c_str());
	return 0;
}

void Palette::initialize() {
	if ( initialized )
		return;

	initialized = true;

	NosuchDebug(2,"INITIALIZING globalParams and others!\n");

	// paramTypes = new std::map<std::string, int>();
	paramTypes["smooth"] = GLOBAL_PARAM;
	paramTypes["basedepth"] = GLOBAL_PARAM;
	paramTypes["cursorspeed"] = GLOBAL_PARAM;
	paramTypes["showfps"] = GLOBAL_PARAM;
	paramTypes["changeable"] = GLOBAL_PARAM;
	paramTypes["zexponential"] = GLOBAL_PARAM;
	paramTypes["zmultiply"] = GLOBAL_PARAM;
	paramTypes["minbuttonarea"] = GLOBAL_PARAM;
	paramTypes["depth2d"] = GLOBAL_PARAM;
	paramTypes["area2d"] = GLOBAL_PARAM;
	
	paramTypes["fading"] = GRAPHIC_PARAM | GLOBAL_PARAM;
	paramTypes["clearbg"] = GRAPHIC_PARAM | GLOBAL_PARAM;
	paramTypes["fade"] = GRAPHIC_PARAM | GLOBAL_PARAM;
	paramTypes["luminance"] = GRAPHIC_PARAM | GLOBAL_PARAM;
	paramTypes["saturation"] = GRAPHIC_PARAM | GLOBAL_PARAM;

	paramTypes["mirror"] = GRAPHIC_PARAM;
	paramTypes["shape"] = GRAPHIC_PARAM;
	paramTypes["graphicbehaviour"] = GRAPHIC_PARAM;
	paramTypes["thickness"] = GRAPHIC_PARAM;
	paramTypes["noisevertex"] = GRAPHIC_PARAM;
	paramTypes["hue"] = GRAPHIC_PARAM;
	paramTypes["huefill"] = GRAPHIC_PARAM;
	paramTypes["cyclehue"] = GRAPHIC_PARAM;
	paramTypes["cycleinitialhue"] = GRAPHIC_PARAM;
	paramTypes["filled"] = GRAPHIC_PARAM;
	paramTypes["alphainitial"] = GRAPHIC_PARAM;
	paramTypes["alphafinal"] = GRAPHIC_PARAM;
	paramTypes["alphatime"] = GRAPHIC_PARAM;
	paramTypes["rotanginit"] = GRAPHIC_PARAM;
	paramTypes["rotangspeed"] = GRAPHIC_PARAM;
	paramTypes["rotangdir"] = GRAPHIC_PARAM;
	paramTypes["sizeinitial"] = GRAPHIC_PARAM;
	paramTypes["sizefinal"] = GRAPHIC_PARAM;
	paramTypes["sizetime"] = GRAPHIC_PARAM;
	paramTypes["lifetime"] = GRAPHIC_PARAM;
	paramTypes["speed"] = GRAPHIC_PARAM;
	paramTypes["direction"] = GRAPHIC_PARAM;
	paramTypes["bounce"] = GRAPHIC_PARAM;
	paramTypes["aspect"] = GRAPHIC_PARAM;
	paramTypes["rotauto"] = GRAPHIC_PARAM;
	paramTypes["movedir"] = GRAPHIC_PARAM;
	paramTypes["nsprites"] = GRAPHIC_PARAM;
	// paramTypes["scale"] = GRAPHIC_PARAM;
	// paramTypes["cursorbehaviour"] = GRAPHIC_PARAM;

	paramTypes["minmove"] = MUSIC_PARAM | GLOBAL_PARAM;
	paramTypes["minmovedepth"] = MUSIC_PARAM | GLOBAL_PARAM;
	paramTypes["tonic"] = MUSIC_PARAM | GLOBAL_PARAM;
	paramTypes["controllerzmin"] = MUSIC_PARAM | GLOBAL_PARAM;
	paramTypes["controllerzmax"] = MUSIC_PARAM | GLOBAL_PARAM;
	paramTypes["tonicchange"] = MUSIC_PARAM | GLOBAL_PARAM;

	paramTypes["musicbehaviour"] = MUSIC_PARAM;
	paramTypes["sound"] = MUSIC_PARAM;
	paramTypes["soundset"] = MUSIC_PARAM;
	paramTypes["musicscale"] = MUSIC_PARAM;
	paramTypes["controllerchan"] = MUSIC_PARAM;
	paramTypes["xcontroller"] = MUSIC_PARAM;
	paramTypes["ycontroller"] = MUSIC_PARAM;
	paramTypes["zcontroller"] = MUSIC_PARAM;
	paramTypes["controllerstyle"] = MUSIC_PARAM;
	paramTypes["timefret1y"] = MUSIC_PARAM;
	paramTypes["timefret2y"] = MUSIC_PARAM;
	paramTypes["timefret3y"] = MUSIC_PARAM;
	paramTypes["timefret4y"] = MUSIC_PARAM;
	paramTypes["timefret1q"] = MUSIC_PARAM;
	paramTypes["timefret2q"] = MUSIC_PARAM;
	paramTypes["timefret3q"] = MUSIC_PARAM;
	paramTypes["timefret4q"] = MUSIC_PARAM;
	paramTypes["pitchmin"] = MUSIC_PARAM;
	paramTypes["pitchmax"] = MUSIC_PARAM;
	paramTypes["quantfactor"] = MUSIC_PARAM;
	paramTypes["loopfade"] = MUSIC_PARAM;
	paramTypes["looplength"] = MUSIC_PARAM;
	paramTypes["loopnotes"] = MUSIC_PARAM;
	paramTypes["quantfixed"] = MUSIC_PARAM;
	paramTypes["doquantize"] = MUSIC_PARAM;
	paramTypes["arpeggio"] = MUSIC_PARAM;

	globalDefaults = new ParamList(NULL);
	NosuchDebug(2,"NEW paramlist");
	// globalDefaults->add(new ParamConst("fade", 0.058f));
	globalDefaults->add(new ParamFloat("fade", 0.55, 0.0, 5.0));

	NosuchDebug(1,"DEFAULT LIFETIME is being set to 4!!");
	globalDefaults->add(new ParamFloat("lifetime", 8.0, 0.0, 20.0));
	// globalDefaults->add(new ParamFloat("lifetime", 10.0, 0.0, 20.0));

	// globalDefaults->add(new ParamFloat("scale", 0.1, 0.0, 2.0));
	globalDefaults->add(new ParamFloat("basedepth", 0.5, 0.0, 1.0));
	globalDefaults->add(new ParamFloat("smooth", 0.05, 0.0, 1.0));
	globalDefaults->add(new ParamFloat("cursorspeed", 0.5, 0.1, 1.0));
	globalDefaults->add(new ParamFloat("filled", 1.0, 0.0, 1.0));
	globalDefaults->add(new ParamFloat("bounce", 1.0, 0.0, 1.0));
	globalDefaults->add(new ParamFloat("rotauto", 1.0, 0.0, 1.0));
	globalDefaults->add(new ParamFloat("showfps", 0.0, 0.0, 1.0));
	globalDefaults->add(new ParamFloat("changeable", 1.0, 0.0, 1.0));
	globalDefaults->add(new ParamFloat("fading", 1.0, 0.0, 1.0));
	globalDefaults->add(new ParamFloat("clearbg", 0.0, 0.0, 1.0));
	globalDefaults->add(new ParamString("mirror", "none", GraphicBehaviour::mirrorTypes));
	globalDefaults->add(new ParamFloat("tonicchange", 30*1000, 0.0, 300*1000));
	globalDefaults->add(new ParamFloat("minmove", 0.1, 0.0, 0.3));
	globalDefaults->add(new ParamFloat("minmovedepth", 0.05, 0.0, 0.3));
	globalDefaults->add(new ParamFloat("minbuttonarea", 0.5, 0.1, 0.9));
	globalDefaults->add(new ParamFloat("depth2d", 0.03, 0.001, 1.0));
	globalDefaults->add(new ParamFloat("area2d", 0.03, 0.001, 1.0));
	globalDefaults->add(new ParamFloat("controllerzmin", 0.05, 0.0, 1.0));
	globalDefaults->add(new ParamFloat("controllerzmax", 0.3, 0.0, 1.0));
	globalDefaults->add(new ParamFloat("tonic", 0.0, -12.0, 12.0));
	globalDefaults->add(new ParamFloat("doquantize", 1.0, 0.0, 1.0));
	globalDefaults->add(new ParamFloat("arpeggio", 0.0, 0.0, 1.0));

	// globalDefaults->add(new ParamFloat("alpha", 40.0, 1.0, 255.0));
	// globalDefaults->add(new ParamFloat("alphafade", 0.0, 0.0, 5.0));
	
	globalDefaults->add(new ParamFloat("alphainitial", 1.0, 0.0, 1.0));
	globalDefaults->add(new ParamFloat("alphafinal", 1.0, 0.0, 1.0));
	globalDefaults->add(new ParamFloat("alphatime", 10.0, 0.1, 20.0)); // seconds
	
	globalDefaults->add(new ParamFloat("thickness", 1.0, 1.0, 40.0));
	globalDefaults->add(new ParamFloat("noisevertex", 0.0, 0.0, 1.0));
	globalDefaults->add(new ParamFloat("rotanginit", 0.0, 0.0, 360.0));
	globalDefaults->add(new ParamFloat("rotangspeed", 0.0, -360.0, 360.0));
	globalDefaults->add(new ParamString("rotangdir", "random", GraphicBehaviour::rotangdirTypes));
	globalDefaults->add(new ParamFloat("aspect", 1.0, 1.0, 11.0));
	globalDefaults->add(new ParamFloat("direction", 0.0, 0.0, 360.0));
	// units of the speed parameter are screen widths per second (I think)
	globalDefaults->add(new ParamFloat("speed", 0.1, 0.0, 1.0));
	globalDefaults->add(new ParamFloat("sizeinitial", 2.0, 0.001, 10.0));
	globalDefaults->add(new ParamFloat("sizefinal", 2.00, 0.0, 10.0));
	globalDefaults->add(new ParamFloat("sizetime", 10.0, 0.1, 10.0)); // seconds
	globalDefaults->add(new ParamFloat("nsprites", 100.0, 1.0, 500.0));
	globalDefaults->add(new ParamFloat("hue", 0.0, 0.0, 360.0));
	globalDefaults->add(new ParamFloat("huefill", 0.0, 0.0, 360.0));
	globalDefaults->add(new ParamFloat("cyclehue", 0.0, 0.0, 20.0));
	globalDefaults->add(new ParamFloat("cycleinitialhue", 0.0, 0.0, 20.0));
	globalDefaults->add(new ParamFloat("luminance", 0.5, 0.0, 1.0));
	globalDefaults->add(new ParamFloat("saturation", 1.0, 0.0, 1.0));
	globalDefaults->add(new ParamFloat("zexponential", 2.0, -3.0, 3.0));
	globalDefaults->add(new ParamFloat("zmultiply", 1.4, 0.1, 11.0));
	globalDefaults->add(new ParamString("shape", "square",
			Sprite::spriteShapes));

	// globalDefaults->add(new ParamString("graphicbehaviour", "museum",
	// globalDefaults->add(new ParamString("graphicbehaviour", "default",
	// globalDefaults->add(new ParamString("graphicbehaviour", "STEIM",
	globalDefaults->add(new ParamString("graphicbehaviour", "burn",
			GraphicBehaviour::behaviourTypes));

	globalDefaults->add(new ParamString("movedir", "cursor",
			GraphicBehaviour::movedirTypes));
	// globalDefaults->add(new ParamString("cursorbehaviour", "move",
	// globalDefaults->add(new ParamString("cursorbehaviour", "accumulate",
	// globalDefaults->add(new ParamString("cursorbehaviour", "instantiate",
	// 		Cursor::behaviourTypes));

	// Music parameters
	// globalDefaults->add(new ParamString("musicbehaviour", "default", MusicBehaviour::behaviourTypes));
	// globalDefaults->add(new ParamString("musicbehaviour", "museum", MusicBehaviour::behaviourTypes));
	// globalDefaults->add(new ParamString("musicbehaviour", "STEIM", MusicBehaviour::behaviourTypes));
	globalDefaults->add(new ParamString("musicbehaviour", "burn", MusicBehaviour::behaviourTypes));

	std::list<std::string> noTypes;
	globalDefaults->add(new ParamString("sound", "Bass 01 Pick Bass", Param::noValues));
	globalDefaults->add(new ParamFloat("soundset", 0, 0, 7));
	globalDefaults->add(new ParamString("musicscale", "newage", Scale::scaleTypes));
	// globalDefaults->add(new ParamFloat("realquant", QuarterNoteClicks/4, 0, QuarterNoteClicks*4));
	globalDefaults->add(new ParamString("controllerstyle", "modulationonly", MusicBehaviour::controllerTypes));
	globalDefaults->add(new ParamFloat("controllerchan", 1, 1, 16));
	globalDefaults->add(new ParamFloat("xcontroller", 3, 1, 127));
	globalDefaults->add(new ParamFloat("ycontroller", 2, 1, 127));
	globalDefaults->add(new ParamFloat("zcontroller", 1, 1, 127));
	globalDefaults->add(new ParamFloat("timefret1y", 0.2, 0, 1.0));
	globalDefaults->add(new ParamFloat("timefret2y", 0.45, 0, 1.0));
	globalDefaults->add(new ParamFloat("timefret3y", 0.7, 0, 1.0));
	globalDefaults->add(new ParamFloat("timefret4y", 0.9, 0, 1.0));
	globalDefaults->add(new ParamFloat("timefret1q", 1.0, 0, 1.0));
	globalDefaults->add(new ParamFloat("timefret2q", 0.5, 0, 1.0));
	globalDefaults->add(new ParamFloat("timefret3q", 0.25, 0, 1.0));
	globalDefaults->add(new ParamFloat("timefret4q", 0.125, 0, 1.0));
	globalDefaults->add(new ParamFloat("pitchmin", 33, 0, 127));
	globalDefaults->add(new ParamFloat("pitchmax", 80, 0, 127));
	globalDefaults->add(new ParamFloat("quantfactor", 1.0, 0.5, 2.0));
	globalDefaults->add(new ParamFloat("loopfade", DEFAULT_LOOPFADE, 0.25, 1.0));
	globalDefaults->add(new ParamFloat("looplength", 8, 2, 128));
	globalDefaults->add(new ParamFloat("loopnotes", 25.0, 1.0, 250.0));
	globalDefaults->add(new ParamFloat("quantfixed", 0.0, 0.0, 1.0));

	globalParams = new ParamList(globalDefaults);

	globalRegionOverrideDefaults = new ParamList(NULL);

	std::list<Param*>& params = globalDefaults->paramList();
	for ( std::list<Param*>::iterator i=params.begin(); i != params.end(); i++ ) {
		Param* pi = *i;
		NosuchAssert(pi);
		switch (pi->type()) {
		case Param::FLOAT :
			globalRegionOverrideDefaults->add(new ParamFloat(pi->name(), Param::UNSET_FLOAT,
				pi->floatMinValue(), pi->floatMaxValue()));
			break;
		case Param::STRING :
			globalRegionOverrideDefaults->add(new ParamString(pi->name(), Param::UNSET_STRING,
				pi->stringValues()));
			break;
		default:
			throw NosuchException("Palette::initialize - unable to initialize parameter of type %d",pi->type());
			break;
		}
	}

	globalRegionOverrideParams = new ParamList(globalRegionOverrideDefaults);

	NosuchDebug(1,"END OF INITIALIZING globalParams and others!\n");
}

// THIS IS USED FOR STEIM !!
char* MuseumGraphics[] = {
	"steim_quickshapes.plt",
	"steim_4shapes.plt",

	"square_dance.plt",
	"steim_triangles.plt",

	"line_dance.plt",
	"web_of_outlines.plt",

	"line1.plt",
	"web_of_filled.plt",

	"line1c.plt",
	"line1b.plt",
	"web_of_outlines.plt",
	"trapezoid_slow.plt",
	NULL
};
char* MayGraphics[] = {
	"steim_quickshapes.plt",
	"oily3.plt",     // "line_dance.plt",
	"square_dance.plt",
	"steim_triangles.plt",
	"steim_4shapes.plt",
	"oily3.plt",     // "steim_quickshapes.plt",
	"line1.plt",
	"line1b.plt",
	"line1c.plt",
	"web_of_filled.plt",
	"web_of_outlines.plt",
	"trapezoid_slow.plt",
	NULL
};
char* BurnGraphics[] = {
	"shape_dance2.plt",   // was "steim_quickshapes.plt",
	"oily3.plt",     // "line_dance.plt",
	"burncircles.plt",    // GOOD
	"burn1c.plt",         // GOOD
	"steim_4shapes.plt",
	"oily3b.plt",     // "steim_quickshapes.plt",
	"fuzz1.plt",
	"burncircles2.plt",    // was "square_dance.plt",
	"steim_triangles.plt",
	"web_of_filled.plt",  // GOOD
	"line1d.plt",         // GOOD
	"burn1c.plt",         // GOOD
	NULL
};

EffectSet buttonEffectSet[NUM_EFFECT_SETS] = {
	EffectSet(0,0,0,0,0,0,0,0,0,0,0,0,0),   // 0 - all effects off
	EffectSet(1,1,0,0,0,0,0,0,0,1,0,1,0),   // 1 - twisted, wave warp, edge detect, mirror
	EffectSet(0,0,0,0,0,0,0,0,0,1,0,0,0),   // 2 - edge detection   GOOD
	EffectSet(1,0,0,1,0,0,0,1,0,0,0,0,1),   // 3 - twisted, blur, displace, trails GOOD?
	EffectSet(1,1,0,0,0,0,0,0,0,0,0,0,0),   // 4 - twisted, wave warp
	EffectSet(1,0,0,1,0,0,1,0,0,1,0,0,1),   // 5 - twisted, blur, posterize, edge detect, trails
	EffectSet(0,0,0,0,0,1,1,0,0,1,0,0,1),   // 6 - fragment, posterize, edge detection, trails
	EffectSet(1,0,0,0,0,1,0,0,0,1,0,0,0),   // 7 - twisted, fragment, edge
	EffectSet(0,0,0,1,0,0,1,0,0,1,0,0,1),   // 8 - blur, posterize, edge detect, trails
	EffectSet(1,0,0,1,0,0,0,0,0,1,0,0,1),   // 9 - twisted, blur, edge detect, trails
	EffectSet(0,0,0,1,0,0,1,0,0,0,0,0,0),   // 10 - blur, posterize
	EffectSet(0,0,0,0,0,0,0,1,0,0,0,0,1),   // 11 - displace, trails
};

Palette::Palette(PaletteFF* b) {

	// _highest_nonbutton_region_id = 4;
	NosuchLockInit(&_palette_mutex,"palette");
	currentConfig = "";
	_manifold = b;
	_shifted = false;
	_soundbank = 0;
	_recentCursor = NULL;

	now = 0;  // Don't use Pt_Time(), it may not have been started yet
	NosuchDebug(1,"Palette constructor, setting now to %d",now);

	frames = 0;
	frames_last = now;
	clearButtonDownAndUsed();
	_effectSet = 0;

	char** pp = MuseumGraphics;
	NumMuseumGraphics = 0;
	while ( *pp++ != NULL ) { NumMuseumGraphics++; }
	CurrentMuseumGraphic = 0;

	pp = MayGraphics;
	NumMayGraphics = 0;
	while ( *pp++ != NULL ) { NumMayGraphics++; }
	CurrentMayGraphic = 0;

	pp = BurnGraphics;
	NumBurnGraphics = 0;
	while ( *pp++ != NULL ) { NumBurnGraphics++; }
	CurrentBurnGraphic = 0;

#if 0
	NosuchDebug(1,"Forcibly initializing regions");
	for ( int r=0; r<=MAX_REGIONS; r++ ) {
		NosuchDebug(1,"Initializing region r=%d",r);
		Region* rgn = getRegion(r);
	}
#endif

	reInitParams();

	if ( _singleton != NULL ) {
		NosuchDebug("HEY!  Palette is instantiated twice!?");
	}
	_singleton = this;
}

void
Palette::init_loops() {
	for ( size_t i=0; i < _regions.size(); i++ ) {
		NosuchDebug(1,"Initializing loop r=%d",i);
		_regions[i]->init_loop();
	}
}

Palette::~Palette() {
	for ( size_t i=0; i < _regions.size(); i++ ) {
		if ( _regions[i] ) {
			delete _regions[i];
			_regions[i] = NULL;
		}
	}
}

void
Palette::initRegionSounds() {
	for ( size_t i=0; i < _regions.size(); i++ ) {
		_regions[i]->initSound();
	}
}

void
Palette::ClearAllLoops(bool loopingoff) {
	for ( size_t i=0; i < _regions.size(); i++ ) {
		Region* r = _regions[i];
		if ( r!=NULL && r->isSurface() ) {
			NosuchDebug(1,"Clearing loop of region=%d",r->id);
			r->loop()->Clear();
			if ( loopingoff ) {
				r->Looping(false);
			}
		}
	}
}

void
Palette::SetAllLooping(bool looping, float fade) {
	NosuchDebug("Palette::SetAllLooping looping=%d",looping);
	for ( size_t i=0; i < _regions.size(); i++ ) {
		Region* r = _regions[i];
		if ( r!=NULL && r->isSurface() ) {
			r->Looping(looping);
			if ( looping && fade >= 0.0f ) {
				r->loopfadeValue(fade);
			}
		}
	}
}

void
Palette::SetAllArpeggio(bool arp) {
	NosuchDebug("Palette::SetAllArpeggio arp=%d",arp);
	for ( size_t i=0; i < _regions.size(); i++ ) {
		Region* r = _regions[i];
		if ( r!=NULL && r->isSurface() ) {
			r->Arpeggio(arp);
		}
	}
}

void
Palette::SetAllFullRange(bool full) {
	NosuchDebug("Palette::SetAllFullRange full=%d",full);
	for ( size_t i=0; i < _regions.size(); i++ ) {
		Region* r = _regions[i];
		if ( r!=NULL && r->isSurface() ) {
			r->FullRange(full);
		}
	}
}

void Palette::buttonDown(std::string bn) {
	_buttonDown[bn] = true;
	PyEvent* e = new ButtonDownPyEvent(bn);
	addPyEvent(e);
}

void Palette::buttonUp(std::string bn) {
	_buttonDown[bn] = false;
	addPyEvent(new ButtonUpPyEvent(bn));
}

void Palette::cursorDown(Cursor* c) {
	NosuchVector pos = c->current_pos();
	addPyEvent(new CursorDownPyEvent(c->region()->name,c->sid(),
		pos.x,pos.y,c->current_depth()));
}

void Palette::cursorDrag(Cursor* c) {
	NosuchVector pos = c->current_pos();
	addPyEvent(new CursorDragPyEvent(c->region()->name,c->sid(),
		pos.x,pos.y,c->current_depth()));
}

void Palette::cursorUp(Cursor* c) {
	NosuchVector pos = c->current_pos();
	addPyEvent(new CursorUpPyEvent(c->region()->name,c->sid(),
		pos.x,pos.y));
}

void Palette::addPyEvent(PyEvent* e) {
	if ( ! _manifold->python_events_disabled() ) {
		_pyevents.push_back(e);
	}
}

PyEvent* Palette::popPyEvent() {
	if ( _manifold->python_events_disabled() ) {
		return NULL;
	}
	PyEvent* e;
	Lock();
	if ( _pyevents.size() == 0 )
		e = NULL;
	else {
		e = _pyevents.front();
		_pyevents.pop_front();
	}
	Unlock();
	return e;
}

void Palette::reInitParams() {
	NosuchDebug(1,"Palette::REINITPARAMS");

	Lock();
	_p_fade = globalParams->getOrCreate("fade");
	_p_showfps = globalParams->getOrCreate("showfps");
	_p_clearbg = globalParams->getOrCreate("clearbg");
	_p_fading = globalParams->getOrCreate("fading");

	for ( size_t i=0; i < _regions.size(); i++ ) {
		getRegion(i)->reInitParams();
	}
	Unlock();
}

void Palette::setGlobalParamFloat(std::string nm, float f) {
	Param* p = globalParams->get(nm);
	NosuchAssert(p);
	p->setFloatValue(f);
}

void Palette::setGlobalParamString(std::string nm, std::string s) {
	Param* p = globalParams->get(nm);
	NosuchAssert(p);
	p->setStringValue(s);
}

Param* Palette::getGlobalParam(std::string nm) {
	return getParam(nm, -1, false);
}

Param* Palette::getRegionParam(std::string nm, int r, bool createIfMissing)
{
	// return getParam(nm,r,true);
	if (r == REGIONID_FOR_GLOBAL_PARAMS) {
		return globalParams->get(nm, createIfMissing);
	} else if (r == REGIONID_FOR_OVERRIDE_PARAMS) {
		return globalRegionOverrideParams->get(nm, createIfMissing);
	} else if (r >= 0) {
		return getRegion(r)->params()->get(nm, createIfMissing);
	} else {
		NosuchDebug("Unexpected region value in getRegionParam: " + r);
		return NULL;
	}
}

Param* Palette::getParam(std::string nm, int r, bool createIfMissing) {
	if (r < 0)
		return globalParams->get(nm);
	else {
		return getRegion(r)->params()->get(nm, createIfMissing);
	}
}

float Palette::getGlobalParamFloat(std::string nm) {
	float f;
	f = globalParams->get(nm)->floatValue();
	return f;
}

static void writestr(std::ofstream& out, std::string s) {
	const char* p = s.c_str();
	out.write(p,s.size());
}

void Palette::randConfig() {

}

bool Palette::paramIsOfType(std::string name, int pt) {
	if ( pt == ALL_PARAM )
		return true;
	return ((paramTypes[name] & pt) != 0);
}

void
Palette::ConfigSave(std::string name, std::string paramtype)
{
	std::string filename = ConfigPath(name,paramtype);

	std::ofstream f(filename.c_str());
	if ( f.fail() ) {
		throw NosuchException("Unable to open config: %s",filename.c_str() );
	} else {
		saveConfig(f,paramtype);
		f.close();
	}
}

void Palette::saveConfig(std::ofstream& out, std::string paramtype) {
	int pt = paramTypeStringToType(paramtype);
	std::string tab = "\t";
	writestr(out, "{\n");
	writestr(out, tab + "\"global\": {\n");
	std::string sep = tab + tab;

	std::list<Param*>& pl = globalParams->paramList();
	for ( std::list<Param*>::iterator i = pl.begin(); i != pl.end(); i++ ) {
		Param* p = *i;
		NosuchAssert(p);
		if ( paramIsOfType(p->name(),pt) ) {
			writestr(out, sep + "\"" + p->name() + "\": " + p->toJSON());
			sep = ",\n" + tab + tab;
		}
	}
	writestr(out, tab + "\n" + tab + "},\n");

	writestr(out, tab + "\"overrides\": {\n");
	sep = tab + tab;
	std::list<Param*>& pl2 = globalRegionOverrideDefaults->paramList();
	for ( std::list<Param*>::iterator i = pl2.begin(); i != pl2.end(); i++ ) {
		Param* p0 = *i;
		NosuchAssert(p0);
		if ( ! paramIsOfType(p0->name(),pt) ) {
			continue;
		}
		// We've got a parameter of the desired type.
		// See if it's actually overridden.
		Param* found = NULL;
		std::list<Param*>& pl3 = globalRegionOverrideParams->paramList();
		for ( std::list<Param*>::iterator i3 = pl3.begin(); i3 != pl3.end(); i3++ ) {
			Param* p3 = *i3;
			NosuchAssert(p3);
			if ( p3->name() == p0->name() ) {
				found = p3;
				break;
			}
		}
		if ( found != NULL ) {
			writestr(out, sep + "\"" + found->name() + "\": " + found->toJSON());
			sep = ",\n" + tab + tab;
		} else {
			writestr(out, sep + "\"" + p0->name() + "\": " + p0->toJSON() );
			sep = ",\n" + tab + tab;
		}
	}
	writestr(out, tab + "\n" + tab + "},\n");
	writestr(out, tab + "\"regions\": [\n");
	sep = tab + tab;

	Lock();
	for ( size_t i=0; i<_regions.size(); i++ ) {
		Region* region = _regions[i];
		std::string sep2 = "\n" + tab + tab + tab;
		writestr(out, sep + "{ \"id\": " + NosuchSnprintf("%d",region->id) + ", \"params\":" + sep2 + "{");

		std::list<Param*>& pl = region->params()->paramList();
		for ( std::list<Param*>::iterator it = pl.begin(); it != pl.end(); it++ ) {
			Param* p = *it;
			NosuchAssert(p);
			if ( paramIsOfType(p->name(),pt) ) {
				writestr(out, sep2 + "\"" + p->name() + "\": " + p->toJSON());
				sep2 = ",\n" + tab + tab + tab;
			}
		}
		writestr(out, "\n" + tab + tab + tab + "}\n");
		writestr(out, tab + tab + "}");
		sep = ",\n" + tab + tab;
	}
	writestr(out, "\n" + tab + "]\n");
	writestr(out, "}\n");
	Unlock();
}

// static Iterator<String> stringKeyIterator(JSONObject obj) {
// 	Iterator<String> pt = obj.keys();
// 	return pt;
// }

static std::string debugJson(cJSON *j, int indent) {
	std::string s = std::string(indent,' ').c_str();
	switch (j->type) {
	case cJSON_False:
		s += NosuchSnprintf("%s = False\n",j->string);
		break;
	case cJSON_True:
		s += NosuchSnprintf("%s = True\n",j->string);
		break;
	case cJSON_NULL:
		s += NosuchSnprintf("%s = NULL\n",j->string);
		break;
	case cJSON_Number:
		s += NosuchSnprintf("%s = (number) %.3f\n",j->string,j->valuedouble);
		break;
	case cJSON_String:
		s += NosuchSnprintf("%s = (string) %s\n",j->string,j->valuestring);
		break;
	case cJSON_Array:
		s += NosuchSnprintf("%s = (array)\n",j->string);
		for ( cJSON* j2=j->child; j2!=NULL; j2=j2->next ) {
			for ( cJSON* j3=j2->child; j3!=NULL; j3=j3->next ) {
				s += debugJson(j3,indent+3);
			}
		}
		break;
	case cJSON_Object:
		s += NosuchSnprintf("%s = object\n",j->string==NULL?"NULL":j->string);
		for ( cJSON* j2=j->child; j2!=NULL; j2=j2->next ) {
			s += debugJson(j2,indent+3);
		}
		break;
	default:
		s += NosuchSnprintf("Unable to handle JSON type=%d in debugJSON?\n",j->type);
		break;
	}
	return s;
}

std::string jsonValueString(cJSON* j) {
	std::string val;

	switch (j->type) {
	case cJSON_Number:
		val = NosuchSnprintf("%f",j->valuedouble);
		break;
	case cJSON_String:
		val = j->valuestring;
		break;
	default:
		throw NosuchException("jsonValueString not prepared to handle type=%d",j->type);
	}
	return val;
}

void Palette::loadConfig(std::ifstream &f) {
	
	bool clearit = false;

	// Read File Line By Line
	std::string line;
	std::string data = "";
	while (!std::getline(f,line,'\n').eof()) {
		// Print the content on the console
		data += line;
	}
	if ( clearit ) {
		globalParams->clear();
	}
	cJSON *json = cJSON_Parse(data.c_str());
	if ( json->type != cJSON_Object ) {
		throw NosuchException("JSON file didn't contain an Object?");
	}
	if ( NosuchDebugLevel > 0 ) {
		NosuchDebug("JSON of Config file follows:\n%s\n",debugJson(json,0).c_str());
	}
	cJSON *j = cJSON_GetObjectItem(json,"global");
	cJSON *j2;
	for ( j2=j->child; j2!=NULL; j2=j2->next ) {
		std::string key = j2->string;
		std::string val = jsonValueString(j2) ;
		Param* kp = globalDefaults->get(key,false,false,false);
		if ( kp == NULL ) {
			NosuchDebug("Config parameter '%s' in globals - unrecognized, ignored",key.c_str());
			continue;
		}
		int ptype = kp->type();
		Param* np = Param::make(key, val, ptype);
		// println("  global key=" + key+" val="+val+" type="+ptype);
		globalParams->set(np);
	}

	if ( clearit ) {
		globalRegionOverrideParams->clear();
	}
	j = cJSON_GetObjectItem(json,"overrides");
	for ( j2=j->child; j2!=NULL; j2=j2->next ) {
		std::string key = j2->string;
		std::string val = jsonValueString(j2) ;
		Param* kp = globalRegionOverrideParams->get(key,false,false,false);
		if ( kp == NULL ) {
			NosuchDebug("Config parameter '%s' in overrides - unrecognized, ignored",key.c_str());
			continue;
		}
		int ptype = kp->type();
		Param* np = Param::make(key, val, ptype);
		// NosuchDebug("CONFIG overrides key=%s val=%s ptype=%d",key.c_str(),val.c_str(),ptype);
		globalRegionOverrideParams->set(np);
#if 0
		if ( np->type() == Param::FLOAT ) {
			NosuchDebug("SET FLOAT GlobalAreaOverrideParams=%d np=%d val=%.4f",
				(int)globalRegionOverrideParams,(int)np,np->floatValue());
		}
#endif
	}

	j = cJSON_GetObjectItem(json,"regions");
	if ( j->type != cJSON_Array ) {
		throw NosuchException("regions object in JSON isn't an array!?");
	}
	int nregions = cJSON_GetArraySize(j);
	for (int i = 0; i < nregions; i++) {
		cJSON* ja = cJSON_GetArrayItem(j,i);
		cJSON* j_id = cJSON_GetObjectItem(ja,"id");
		cJSON* j_prms = cJSON_GetObjectItem(ja,"params");
		std::string nm = "";
		switch(j_id->valueint) {
		case 1: nm = "LOWER"; break;
		case 2: nm = "LEFT"; break;
		case 3: nm = "RIGHT"; break;
		case 4: nm = "UPPER"; break;
		}
		if ( nm == "" ) {
			NosuchDebug(2,"Ignoring region id=%d in config",j_id->valueint);
			continue;
		}
		Region* region = GetRegionNamed(nm);
		if ( region == NULL ) {
			throw NosuchException("Can't get region!?");
		}
		cJSON* j4;
		for ( j4=j_prms->child; j4!=NULL; j4=j4->next ) {
			std::string key = j4->string;
			std::string val = jsonValueString(j4) ;
			Param* kp = globalDefaults->get(key,false,false,false);
			if ( kp == NULL ) {
				NosuchDebug("Config parameter '%s' in regions - unrecognized, ignored",key.c_str());
				continue;
			}
			int ptype = kp->type();
			Param* np = Param::make(key, val, ptype);
			region->params()->set(np);
		}
	}
	
	reInitParams();
}

void Palette::advanceTo(int tm) {

	NosuchDebug(1,"===================== Palette::advanceTo tm=%d setting now",tm);
	now = tm;
	bool addrandom = false;
	if ( idleattract > 0 && now > (lastsprite+idleattract) ){
		NosuchDebug("Idle, should be forcing a new sprite\n");
		lastsprite = now;
		addrandom = true;
	}
	Lock();
	for ( size_t i=0; i<_regions.size(); i++ ) {
		Region* region = _regions[i];
		region->advanceTo(now);
		if ( addrandom ) {
			region->addrandom();
		}
	}
	Unlock();

	if (_p_showfps->boolValue()) {
		frames++;
		// Every second, print out FPS
		if (now > (frames_last + 1000)) {
			NosuchDebug("FPS=%d  now=%d",frames,now);
			frames = 0;
			frames_last = now;
		}
	}
}

// public float random(int n) {
// return app.random(n);
// }

int Palette::draw() {

	// pthread_t thr = pthread_self ();
	// NosuchDebug("Palette::draw start thr=%d,%d",(int)(thr.p),thr.x);

	for ( size_t i=0; i<_regions.size(); i++ ) {
		Region* region = _regions[i];
		region->draw(_manifold);
	}

	return 0;
}

void
Palette::schedSessionEnd(std::string sid) {
	NosuchDebug(2,"schedSessionEnd sid=%s",sid.c_str());
	NosuchScheduler* s = scheduler();
	s->IncomingSessionEnd(s->CurrentClick(),sid);
	return;
}

MidiMsg*
Palette::schedNewNoteInMilliseconds(std::string sid,int ch,int milli,int pitch) {
	int clicks = (int)(0.5 + milli * scheduler()->ClicksPerMillisecond);
	NosuchDebug(1,"schedNewNoteInMilliseconds milli=%d clicks=%d _currentclick=%d",milli,clicks,scheduler()->_currentclick);
	MidiMsg *m = schedNewNoteInClicks(sid,ch,clicks,pitch);
	NosuchDebug(1,"schedNewNoteInMilliseconds end");
	return m;
}

MidiMsg*
Palette::schedNewNoteInClicks(std::string sid,int ch,int clicks,int pitch) {
	NosuchDebug(1,"schedNewNoteInClicks start sid=%s",sid.c_str());
	if ( NosuchDebugMidiNotes ) {
		NosuchDebug("NEWNOTE! sid=%s  chan=%d",sid.c_str(),ch);
	}
	if ( ch <= 0 ) {
		NosuchDebug("NOT SENDING MIDI NOTE!  ch=%d",ch);
		return NULL;
	}

	// Should the scheduler be locked, here?

	int velocity = 127;  // Velocity should be based on something else
	MidiMsg* m1 = MidiNoteOn::make(ch,pitch,velocity);
	NosuchDebug(1,"schedNewNoteInClicks mid sid=%s",sid.c_str());

	scheduler()->IncomingMidiMsg(m1,clicks,sid);
	NosuchDebug(1,"schedNewNoteInClicks end sid=%s",sid.c_str());

	return m1;
}

void Palette::checkCursorUp(int milli) {
	for ( size_t i=0; i < _regions.size(); i++ ) {
		_regions[i]->checkCursorUp(milli);
	}
}

Region* Palette::getRegion(int r) {
	// NosuchDebug("getRegion r=%d  _regions.size=%d",r, _regions.size());
	// NosuchAssert(r<_regions.size());

	if ( r < (int)_regions.size() ) {
		// NosuchDebug("Returning existing region r=%d region=%d",r,(int)_regions[r]);
		return _regions[r];
	}
	// create it (and any lower-numbered regions) if it doesn't exist

	Lock();
	for ( int rnum=_regions.size(); rnum <= r; rnum++ ) {
		NosuchDebug(1,"getRegion creating new Region, rnum=%d",rnum);
		Region* rp = new Region(this,rnum);
		// rp->initParams();
		NosuchDebug(1,"CREATING Region r=%d",rnum);
		_regions.push_back(rp);
	}
	Unlock();

	// NosuchDebug("getRegion end _regions.size=%d",_regions.size());
	return _regions[r];
}

void Palette::SetMostRecentCursorDown(Cursor* c) {
	// NosuchDebug(2,"Setting MostRecentCursor to %s",c==NULL?"NULL":c->DebugString().c_str());
	_recentCursor = c;
}

std::string Palette::ConfigDir(std::string paramtype) {
	std::string dirname = "patches\\config_" + paramtype;
	return NosuchPublicPath(dirname);
}

std::string Palette::ConfigNormalize(std::string name) {
	std::string suff = name.substr(name.length()-configSuffix.length());
	// NosuchDebug("ConfigNormalize, name=%s suff=%s",name.c_str(),suff.c_str());
	if (suff != configSuffix) {
		name += configSuffix;
	}
	return name;
}

void Palette::ConfigFiles(std::string paramtype,std::vector<std::string>& files) {

	UINT counter(0);
	bool working(true);
	std::string buffer;
	std::string fileName[1000];

	WIN32_FIND_DATAA myimage;
	std::string lookfor = ConfigDir(paramtype) + "\\*" + configSuffix;
	HANDLE myHandle=FindFirstFileA(lookfor.c_str(),&myimage);

	// NosuchDebug("ConfigFiles start");
	if(myHandle!=INVALID_HANDLE_VALUE) {
		buffer = std::string(myimage.cFileName);
		files.push_back(buffer);

		while (FindNextFileA(myHandle, &myimage) != 0) {
			std::string file = std::string(myimage.cFileName);
			int i = file.find('~');
			// NosuchDebug("ConfigFiles file=%s i=%d",file.c_str(),i);
			if ( i >= 0 ) {
				continue;
			}
			files.push_back(file);
		}
		DWORD dwError = GetLastError();
		FindClose(myHandle);

		if (dwError != ERROR_NO_MORE_FILES) {
			 NosuchDebug("FindNextFile error is %u.\n", dwError);
		}
	}
	if (files.size() == 0) {
		throw NosuchException("There are no config files matching %s !?",lookfor.c_str());
	}
}

std::string Palette::ConfigPath(std::string name, std::string paramtype) {
	std::string s = ConfigDir(paramtype) + configSeparator
			+ ConfigNormalize(name);
	return NosuchForwardSlash(s);
	// return s;
}

int Palette::ConfigIndex(std::vector<std::string> &files, std::string name, std::string paramtype) {
	ConfigFiles(paramtype,files);
	name = ConfigNormalize(name);
	for (unsigned int n = 0; n < files.size(); n++) {
		std::string s = files[n];
		if (name == s) {
			return n;
		}
	}
	return -1;
}

std::string Palette::ConfigNext(std::string name, std::string paramtype, int dir) {
	std::vector<std::string> files;
	ConfigFiles(paramtype,files);
	int i = ConfigIndex(files, name, paramtype);
	i += dir;
	if (i < 0) {
		i = 0;
	} else if (i > (int)(files.size() - 1)) {
		i = files.size() - 1;
	}
	return files[i];
}

std::string Palette::ConfigNew(std::string name, std::string paramtype) {
	std::string base = name;
	std::string suff = base.substr(base.length()-configSuffix.length());
	NosuchDebug("ConfigNew, name=%s suff=%s",name.c_str(),suff.c_str());
	if (suff == configSuffix) {
		base = name.substr(0, name.length() - configSuffix.length());
	}
	NosuchDebug("ConfigNew, name=%s suff=%s base=%s",name.c_str(),suff.c_str(),base.c_str());
	// If there's a _, remove it and everything after
	int i = base.rfind('_');
	if (i > 0) {
		base = base.substr(0, i);
	}
	std::string cp = ConfigPath(base, paramtype);
	struct _stat statbuff;
	if( _stat( cp.c_str(), &statbuff ) < 0 ) {
	    // file doesn't exist, so it's okay as a new name
		return base;
	}
	i = 0;
	while (true) {
		std::string newbase = NosuchSnprintf("%s_%d",base.c_str(),i);
		std::string fn = ConfigPath(newbase, paramtype);
		if( _stat( fn.c_str(), &statbuff ) < 0 ) {
		    // file doesn't exist, so it's okay as a new name
			return newbase;
		}
		i++;
	}
}

std::string Palette::ConfigRand(std::string name, std::string paramtype) {
	std::vector<std::string> files;
	ConfigFiles(paramtype,files);
	NosuchAssert(files.size()>0);
	if (files.size() == 1) {
		return files[0];
	}
	// Make sure we get a new one. name might be null
	int curri = (name == "") ? -1 : ConfigIndex(files,name,paramtype);
	int randi;
	while (1) {
		randi = rand() % files.size();
		if (randi != curri) {
			break;
		}
	}
	return files[randi];
}

std::string Palette::ConfigLoadRand(std::string paramtype) {
	std::string name = ConfigRand(currentConfig,paramtype);
	// println("ConfigLoadRand rand config = "+name);
	ConfigLoad(name,paramtype);
	return name;
}

void Palette::ConfigLoad(std::string name, std::string paramtype) {
	std::string filename = ConfigPath(name, paramtype);
	NosuchDebug("ConfigLoad type=%s file=%s",paramtype.c_str(),filename.c_str());

	std::ifstream f(filename.c_str(), std::ifstream::in | std::ifstream::binary);
	if ( ! f.is_open() ) {
		throw NosuchException("Unable to open config file: %s",filename.c_str());
	}
	_manifold->lock_palette();
	loadConfig(f);
	_manifold->unlock_palette();
	f.close();
	currentConfig = name;
	NosuchDebug(1,"ConfigLoad successful");
}
